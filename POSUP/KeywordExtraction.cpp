
#include "KeywordExtraction.h"
#include "Utils.h"


KeywordExtraction::KeywordExtraction()
{
}

KeywordExtraction::~KeywordExtraction()
{
}

/**
* Function Name: extractKeywords
*
* Description:
* Extract unique keywords from input file which are tokenized by delimiters defined in DSSE_Params.h
*
* @param rKeywordsDictionary: (output) list of unique keyword being extracted
* @param file_name: (input) name of input file
* @param path: (input) location of input file
* @return	0 if successful
*/
int KeywordExtraction::extractKeywords(TYPE_KEYWORD_DICTIONARY &rKeywordsDictionary, string file_name,string path)
{
	unsigned long int keyword_num = 0;
	string fname_with_path;

	// create a file-reading object
	ifstream fin;

	fname_with_path.append(path);
	fname_with_path.append(file_name);

	// open a file
	fin.open(fname_with_path.c_str(), ios::binary | ios::in);

	if (!fin.good())
		return -1; // exit if file not found

				   // Extract keywords from a file
	extractWords_using_find_first_of(rKeywordsDictionary, &keyword_num, fin);

	fin.close();

	return 0;
}

int KeywordExtraction::extractWords_using_find_first_of(TYPE_KEYWORD_DICTIONARY &rKeywordsDictionary, unsigned long int *pKeywordNum, ifstream &rFin)
{
		string line, word;
		while (getline(rFin, line))
		{
			size_t prev = 0, pos;
			trim(line);
			while ((pos = line.find_first_of(delimiter, prev)) != std::string::npos)
			{
				if (pos > prev)
				{
					word = line.substr(prev, pos - prev);
					trim(word);
					//convert the word to lower case
					std::transform(word.begin(), word.end(), word.begin(), ::tolower);
					rKeywordsDictionary.insert(word);
					*pKeywordNum = *pKeywordNum + 1;
				}

				prev = pos + 1;
			}
			if (prev < line.length()) {
				word = line.substr(prev, std::string::npos);
				trim(word);
				//convert the word to lower case
				std::transform(word.begin(), word.end(), word.begin(), ::tolower);
				rKeywordsDictionary.insert(word);
				*pKeywordNum = *pKeywordNum + 1;
			}

		}
	return 0;
}



/**
* Function Name: createInvertedIndex
*
* Description:
* create keyword-file pair from the file collection
*
* @param kw_file_pair: (output) list of keyword-file pair being extracted
* @param rT_W: (output) keyword hash table
* @param rT_F: (output) file hash table
* @param lstFree_keyword_idx: (input) list of empty indices used for keyword (e.g., empty row index)
* @param lstFree_file_idx: (input) list of empty indices used for file (e.g., empty column index)
* @param path: (input) location of the file collection
* @param pKey: (input) key generated by genMasterKey which is used for hash table
* @return	0 if successful
*/
int KeywordExtraction::createInvertedIndex(string path, map <string, string> &invertedIdx)
{
	int keyword_len = 0;
	string word;
	TYPE_KEYWORD_DICTIONARY words_per_file;
	set<string>::iterator iter;

	vector<string> filename;
	filename.clear();
	vector<string> filePath;
	filePath.clear();
	getAllFiles(path, filename, filePath);
	for (int i = 0; i < filename.size(); i++)
	{
		words_per_file.clear();
		this->extractKeywords(words_per_file, filename[i], filePath[i]);

		for (iter = words_per_file.begin(); iter != words_per_file.end(); iter++)
		{
			word = *iter;
			keyword_len = word.size();
			if (keyword_len>0)
			{
				// create keyword-file pairs 
				// if this keyword does not exist, add it
				if (invertedIdx.find(word) == invertedIdx.end())
				{
					pair<string, string> tmp(word, "");
					invertedIdx.insert(tmp);
				}
				invertedIdx[word] += (filename[i] + ",");
			}
			else
			{
				continue;
			}
			word.clear();
		}
	}
	word.clear();
	filename.clear();
	filePath.clear();
	return 0;
}